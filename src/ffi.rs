/* automatically generated by rust-bindgen 0.59.1 */

pub const VPX_IMAGE_ABI_VERSION: u32 = 5;
pub const VPX_IMG_FMT_PLANAR: u32 = 256;
pub const VPX_IMG_FMT_UV_FLIP: u32 = 512;
pub const VPX_IMG_FMT_HAS_ALPHA: u32 = 1024;
pub const VPX_IMG_FMT_HIGHBITDEPTH: u32 = 2048;
pub const VPX_PLANE_PACKED: u32 = 0;
pub const VPX_PLANE_Y: u32 = 0;
pub const VPX_PLANE_U: u32 = 1;
pub const VPX_PLANE_V: u32 = 2;
pub const VPX_PLANE_ALPHA: u32 = 3;
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101406;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const VPX_CODEC_ABI_VERSION: u32 = 9;
pub const VPX_CODEC_CAP_DECODER: u32 = 1;
pub const VPX_CODEC_CAP_ENCODER: u32 = 2;
pub const VPX_CODEC_CAP_HIGHBITDEPTH: u32 = 4;
pub const VPX_MAXIMUM_WORK_BUFFERS: u32 = 8;
pub const VP9_MAXIMUM_REF_BUFFERS: u32 = 8;
pub const VPX_DECODER_ABI_VERSION: u32 = 12;
pub const VPX_CODEC_CAP_PUT_SLICE: u32 = 65536;
pub const VPX_CODEC_CAP_PUT_FRAME: u32 = 131072;
pub const VPX_CODEC_CAP_POSTPROC: u32 = 262144;
pub const VPX_CODEC_CAP_ERROR_CONCEALMENT: u32 = 524288;
pub const VPX_CODEC_CAP_INPUT_FRAGMENTS: u32 = 1048576;
pub const VPX_CODEC_CAP_FRAME_THREADING: u32 = 2097152;
pub const VPX_CODEC_CAP_EXTERNAL_FRAME_BUFFER: u32 = 4194304;
pub const VPX_CODEC_USE_POSTPROC: u32 = 65536;
pub const VPX_CODEC_USE_ERROR_CONCEALMENT: u32 = 131072;
pub const VPX_CODEC_USE_INPUT_FRAGMENTS: u32 = 262144;
pub const VPX_CODEC_USE_FRAME_THREADING: u32 = 524288;
pub const vpx_img_fmt_VPX_IMG_FMT_NONE: vpx_img_fmt = 0;
pub const vpx_img_fmt_VPX_IMG_FMT_YV12: vpx_img_fmt = 769;
pub const vpx_img_fmt_VPX_IMG_FMT_I420: vpx_img_fmt = 258;
pub const vpx_img_fmt_VPX_IMG_FMT_I422: vpx_img_fmt = 261;
pub const vpx_img_fmt_VPX_IMG_FMT_I444: vpx_img_fmt = 262;
pub const vpx_img_fmt_VPX_IMG_FMT_I440: vpx_img_fmt = 263;
pub const vpx_img_fmt_VPX_IMG_FMT_NV12: vpx_img_fmt = 265;
pub const vpx_img_fmt_VPX_IMG_FMT_I42016: vpx_img_fmt = 2306;
pub const vpx_img_fmt_VPX_IMG_FMT_I42216: vpx_img_fmt = 2309;
pub const vpx_img_fmt_VPX_IMG_FMT_I44416: vpx_img_fmt = 2310;
pub const vpx_img_fmt_VPX_IMG_FMT_I44016: vpx_img_fmt = 2311;
#[doc = "\\brief List of supported image formats"]
pub type vpx_img_fmt = ::std::os::raw::c_uint;
pub use self::vpx_img_fmt as vpx_img_fmt_t;
#[doc = "< Unknown"]
pub const vpx_color_space_VPX_CS_UNKNOWN: vpx_color_space = 0;
#[doc = "< BT.601"]
pub const vpx_color_space_VPX_CS_BT_601: vpx_color_space = 1;
#[doc = "< BT.709"]
pub const vpx_color_space_VPX_CS_BT_709: vpx_color_space = 2;
#[doc = "< SMPTE.170"]
pub const vpx_color_space_VPX_CS_SMPTE_170: vpx_color_space = 3;
#[doc = "< SMPTE.240"]
pub const vpx_color_space_VPX_CS_SMPTE_240: vpx_color_space = 4;
#[doc = "< BT.2020"]
pub const vpx_color_space_VPX_CS_BT_2020: vpx_color_space = 5;
#[doc = "< Reserved"]
pub const vpx_color_space_VPX_CS_RESERVED: vpx_color_space = 6;
#[doc = "< sRGB"]
pub const vpx_color_space_VPX_CS_SRGB: vpx_color_space = 7;
#[doc = "\\brief List of supported color spaces"]
pub type vpx_color_space = ::std::os::raw::c_uint;
pub use self::vpx_color_space as vpx_color_space_t;
#[doc = "< Y [16..235], UV [16..240]"]
pub const vpx_color_range_VPX_CR_STUDIO_RANGE: vpx_color_range = 0;
#[doc = "< YUV/RGB [0..255]"]
pub const vpx_color_range_VPX_CR_FULL_RANGE: vpx_color_range = 1;
#[doc = "\\brief List of supported color range"]
pub type vpx_color_range = ::std::os::raw::c_uint;
pub use self::vpx_color_range as vpx_color_range_t;
#[doc = "\\brief Image Descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image {
    #[doc = "< Image Format"]
    pub fmt: vpx_img_fmt_t,
    #[doc = "< Color Space"]
    pub cs: vpx_color_space_t,
    #[doc = "< Color Range"]
    pub range: vpx_color_range_t,
    #[doc = "< Stored image width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Stored image height"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Stored image bit-depth"]
    pub bit_depth: ::std::os::raw::c_uint,
    #[doc = "< Displayed image width"]
    pub d_w: ::std::os::raw::c_uint,
    #[doc = "< Displayed image height"]
    pub d_h: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image width"]
    pub r_w: ::std::os::raw::c_uint,
    #[doc = "< Intended rendering image height"]
    pub r_h: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, X"]
    pub x_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< subsampling order, Y"]
    pub y_chroma_shift: ::std::os::raw::c_uint,
    #[doc = "< pointer to the top left pixel for each plane"]
    pub planes: [*mut ::std::os::raw::c_uchar; 4usize],
    #[doc = "< stride between rows for each plane"]
    pub stride: [::std::os::raw::c_int; 4usize],
    #[doc = "< bits per sample (for packed formats)"]
    pub bps: ::std::os::raw::c_int,
    #[doc = "\\brief The following member may be set by the application to associate"]
    #[doc = " data with this image."]
    pub user_priv: *mut ::std::os::raw::c_void,
    #[doc = "< private"]
    pub img_data: *mut ::std::os::raw::c_uchar,
    #[doc = "< private"]
    pub img_data_owner: ::std::os::raw::c_int,
    #[doc = "< private"]
    pub self_allocd: ::std::os::raw::c_int,
    #[doc = "< Frame buffer data associated with the image."]
    pub fb_priv: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_image() {
    assert_eq!(
        ::std::mem::size_of::<vpx_image>(),
        136usize,
        concat!("Size of: ", stringify!(vpx_image))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_image>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).fmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).cs as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).range as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).h as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).bit_depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(bit_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).d_w as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(d_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).d_h as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(d_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).r_w as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(r_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).r_h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(r_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).x_chroma_shift as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(x_chroma_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).y_chroma_shift as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(y_chroma_shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).planes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(planes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).stride as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).bps as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).user_priv as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(user_priv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).img_data as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(img_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).img_data_owner as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(img_data_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).self_allocd as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(self_allocd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image>())).fb_priv as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image),
            "::",
            stringify!(fb_priv)
        )
    );
}
pub type vpx_image_t = vpx_image;
#[doc = "\\brief Representation of a rectangle on a surface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_image_rect {
    #[doc = "< leftmost column"]
    pub x: ::std::os::raw::c_uint,
    #[doc = "< topmost row"]
    pub y: ::std::os::raw::c_uint,
    #[doc = "< width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< height"]
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_image_rect() {
    assert_eq!(
        ::std::mem::size_of::<vpx_image_rect>(),
        16usize,
        concat!("Size of: ", stringify!(vpx_image_rect))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_image_rect>(),
        4usize,
        concat!("Alignment of ", stringify!(vpx_image_rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image_rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image_rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image_rect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_image_rect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_image_rect),
            "::",
            stringify!(h)
        )
    );
}
pub type vpx_image_rect_t = vpx_image_rect;
extern "C" {
    #[doc = "\\brief Open a descriptor, allocating storage for the underlying image"]
    #[doc = ""]
    #[doc = " Returns a descriptor for storing an image of the given format. The"]
    #[doc = " storage for the descriptor is allocated on the heap."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Pointer to storage for descriptor. If this parameter"]
    #[doc = "                         is NULL, the storage for the descriptor will be"]
    #[doc = "                         allocated on the heap."]
    #[doc = " \\param[in]    fmt       Format for the image"]
    #[doc = " \\param[in]    d_w       Width of the image"]
    #[doc = " \\param[in]    d_h       Height of the image"]
    #[doc = " \\param[in]    align     Alignment, in bytes, of the image buffer and"]
    #[doc = "                         each row in the image(stride)."]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to the initialized image descriptor. If the img"]
    #[doc = "         parameter is non-null, the value of the img parameter will be"]
    #[doc = "         returned."]
    pub fn vpx_img_alloc(
        img: *mut vpx_image_t,
        fmt: vpx_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        align: ::std::os::raw::c_uint,
    ) -> *mut vpx_image_t;
}
extern "C" {
    #[doc = "\\brief Open a descriptor, using existing storage for the underlying image"]
    #[doc = ""]
    #[doc = " Returns a descriptor for storing an image of the given format. The"]
    #[doc = " storage for descriptor has been allocated elsewhere, and a descriptor is"]
    #[doc = " desired to \"wrap\" that storage."]
    #[doc = ""]
    #[doc = " \\param[in]    img           Pointer to storage for descriptor. If this"]
    #[doc = "                             parameter is NULL, the storage for the descriptor"]
    #[doc = "                             will be allocated on the heap."]
    #[doc = " \\param[in]    fmt           Format for the image"]
    #[doc = " \\param[in]    d_w           Width of the image"]
    #[doc = " \\param[in]    d_h           Height of the image"]
    #[doc = " \\param[in]    stride_align  Alignment, in bytes, of each row in the image."]
    #[doc = " \\param[in]    img_data      Storage to use for the image"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to the initialized image descriptor. If the img"]
    #[doc = "         parameter is non-null, the value of the img parameter will be"]
    #[doc = "         returned."]
    pub fn vpx_img_wrap(
        img: *mut vpx_image_t,
        fmt: vpx_img_fmt_t,
        d_w: ::std::os::raw::c_uint,
        d_h: ::std::os::raw::c_uint,
        stride_align: ::std::os::raw::c_uint,
        img_data: *mut ::std::os::raw::c_uchar,
    ) -> *mut vpx_image_t;
}
extern "C" {
    #[doc = "\\brief Set the rectangle identifying the displayed portion of the image"]
    #[doc = ""]
    #[doc = " Updates the displayed rectangle (aka viewport) on the image surface to"]
    #[doc = " match the specified coordinates and size. Specifically, sets img->d_w,"]
    #[doc = " img->d_h, and elements of the img->planes[] array."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    #[doc = " \\param[in]    x         leftmost column"]
    #[doc = " \\param[in]    y         topmost row"]
    #[doc = " \\param[in]    w         width"]
    #[doc = " \\param[in]    h         height"]
    #[doc = ""]
    #[doc = " \\return 0 if the requested rectangle is valid, nonzero (-1) otherwise."]
    pub fn vpx_img_set_rect(
        img: *mut vpx_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        w: ::std::os::raw::c_uint,
        h: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Flip the image vertically (top for bottom)"]
    #[doc = ""]
    #[doc = " Adjusts the image descriptor's pointers and strides to make the image"]
    #[doc = " be referenced upside-down."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    pub fn vpx_img_flip(img: *mut vpx_image_t);
}
extern "C" {
    #[doc = "\\brief Close an image descriptor"]
    #[doc = ""]
    #[doc = " Frees all allocated storage associated with an image descriptor."]
    #[doc = ""]
    #[doc = " \\param[in]    img       Image descriptor"]
    pub fn vpx_img_free(img: *mut vpx_image_t);
}
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = "\\brief Operation completed without error"]
pub const vpx_codec_err_t_VPX_CODEC_OK: vpx_codec_err_t = 0;
#[doc = "\\brief Unspecified error"]
pub const vpx_codec_err_t_VPX_CODEC_ERROR: vpx_codec_err_t = 1;
#[doc = "\\brief Memory operation failed"]
pub const vpx_codec_err_t_VPX_CODEC_MEM_ERROR: vpx_codec_err_t = 2;
#[doc = "\\brief ABI version mismatch"]
pub const vpx_codec_err_t_VPX_CODEC_ABI_MISMATCH: vpx_codec_err_t = 3;
#[doc = "\\brief Algorithm does not have required capability"]
pub const vpx_codec_err_t_VPX_CODEC_INCAPABLE: vpx_codec_err_t = 4;
#[doc = "\\brief The given bitstream is not supported."]
#[doc = ""]
#[doc = " The bitstream was unable to be parsed at the highest level. The decoder"]
#[doc = " is unable to proceed. This error \\ref SHOULD be treated as fatal to the"]
#[doc = " stream."]
pub const vpx_codec_err_t_VPX_CODEC_UNSUP_BITSTREAM: vpx_codec_err_t = 5;
#[doc = "\\brief Encoded bitstream uses an unsupported feature"]
#[doc = ""]
#[doc = " The decoder does not implement a feature required by the encoder. This"]
#[doc = " return code should only be used for features that prevent future"]
#[doc = " pictures from being properly decoded. This error \\ref MAY be treated as"]
#[doc = " fatal to the stream or \\ref MAY be treated as fatal to the current GOP."]
pub const vpx_codec_err_t_VPX_CODEC_UNSUP_FEATURE: vpx_codec_err_t = 6;
#[doc = "\\brief The coded data for this stream is corrupt or incomplete"]
#[doc = ""]
#[doc = " There was a problem decoding the current frame.  This return code"]
#[doc = " should only be used for failures that prevent future pictures from"]
#[doc = " being properly decoded. This error \\ref MAY be treated as fatal to the"]
#[doc = " stream or \\ref MAY be treated as fatal to the current GOP. If decoding"]
#[doc = " is continued for the current GOP, artifacts may be present."]
pub const vpx_codec_err_t_VPX_CODEC_CORRUPT_FRAME: vpx_codec_err_t = 7;
#[doc = "\\brief An application-supplied parameter is not valid."]
#[doc = ""]
pub const vpx_codec_err_t_VPX_CODEC_INVALID_PARAM: vpx_codec_err_t = 8;
#[doc = "\\brief An iterator reached the end of list."]
#[doc = ""]
pub const vpx_codec_err_t_VPX_CODEC_LIST_END: vpx_codec_err_t = 9;
#[doc = "\\brief Algorithm return codes"]
pub type vpx_codec_err_t = ::std::os::raw::c_uint;
#[doc = " \\brief Codec capabilities bitfield"]
#[doc = ""]
#[doc = "  Each codec advertises the capabilities it supports as part of its"]
#[doc = "  ::vpx_codec_iface_t interface structure. Capabilities are extra interfaces"]
#[doc = "  or functionality, and are not required to be supported."]
#[doc = ""]
#[doc = "  The available flags are specified by VPX_CODEC_CAP_* defines."]
pub type vpx_codec_caps_t = ::std::os::raw::c_long;
#[doc = " \\brief Initialization-time Feature Enabling"]
#[doc = ""]
#[doc = "  Certain codec features must be known at initialization time, to allow for"]
#[doc = "  proper memory allocation."]
#[doc = ""]
#[doc = "  The available flags are specified by VPX_CODEC_USE_* defines."]
pub type vpx_codec_flags_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_iface {
    _unused: [u8; 0],
}
#[doc = "\\brief Codec interface structure."]
#[doc = ""]
#[doc = " Contains function pointers and other data private to the codec"]
#[doc = " implementation. This structure is opaque to the application."]
pub type vpx_codec_iface_t = vpx_codec_iface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_priv {
    _unused: [u8; 0],
}
#[doc = "\\brief Codec private data structure."]
#[doc = ""]
#[doc = " Contains data private to the codec implementation. This structure is opaque"]
#[doc = " to the application."]
pub type vpx_codec_priv_t = vpx_codec_priv;
#[doc = "\\brief Iterator"]
#[doc = ""]
#[doc = " Opaque storage used for iterating over lists."]
pub type vpx_codec_iter_t = *const ::std::os::raw::c_void;
#[doc = "\\brief Codec context structure"]
#[doc = ""]
#[doc = " All codecs \\ref MUST support this context structure fully. In general,"]
#[doc = " this data should be considered private to the codec algorithm, and"]
#[doc = " not be manipulated or examined by the calling application. Applications"]
#[doc = " may reference the 'name' member to get a printable description of the"]
#[doc = " algorithm."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vpx_codec_ctx {
    #[doc = "< Printable interface name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< Interface pointers"]
    pub iface: *mut vpx_codec_iface_t,
    #[doc = "< Last returned error"]
    pub err: vpx_codec_err_t,
    #[doc = "< Detailed info, if available"]
    pub err_detail: *const ::std::os::raw::c_char,
    #[doc = "< Flags passed at init time"]
    pub init_flags: vpx_codec_flags_t,
    #[doc = "< Configuration pointer aliasing union"]
    pub config: vpx_codec_ctx__bindgen_ty_1,
    #[doc = "< Algorithm private storage"]
    pub priv_: *mut vpx_codec_priv_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vpx_codec_ctx__bindgen_ty_1 {
    pub dec: *const vpx_codec_dec_cfg,
    pub enc: *mut vpx_codec_enc_cfg,
    pub raw: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_codec_ctx__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vpx_codec_ctx__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(vpx_codec_ctx__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_codec_ctx__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_codec_ctx__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx__bindgen_ty_1>())).dec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx__bindgen_ty_1),
            "::",
            stringify!(dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx__bindgen_ty_1>())).enc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx__bindgen_ty_1),
            "::",
            stringify!(enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx__bindgen_ty_1>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx__bindgen_ty_1),
            "::",
            stringify!(raw)
        )
    );
}
#[test]
fn bindgen_test_layout_vpx_codec_ctx() {
    assert_eq!(
        ::std::mem::size_of::<vpx_codec_ctx>(),
        56usize,
        concat!("Size of: ", stringify!(vpx_codec_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_codec_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_codec_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).iface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).err as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).err_detail as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(err_detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).init_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(init_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).config as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_ctx>())).priv_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_ctx),
            "::",
            stringify!(priv_)
        )
    );
}
pub type vpx_codec_ctx_t = vpx_codec_ctx;
#[doc = "<  8 bits"]
pub const vpx_bit_depth_VPX_BITS_8: vpx_bit_depth = 8;
#[doc = "< 10 bits"]
pub const vpx_bit_depth_VPX_BITS_10: vpx_bit_depth = 10;
#[doc = "< 12 bits"]
pub const vpx_bit_depth_VPX_BITS_12: vpx_bit_depth = 12;
#[doc = "\\brief Bit depth for codec"]
#[doc = " *"]
#[doc = " This enumeration determines the bit depth of the codec."]
pub type vpx_bit_depth = ::std::os::raw::c_uint;
pub use self::vpx_bit_depth as vpx_bit_depth_t;
extern "C" {
    #[doc = "\\brief Return the version information (as an integer)"]
    #[doc = ""]
    #[doc = " Returns a packed encoding of the library version number. This will only"]
    #[doc = " include"]
    #[doc = " the major.minor.patch component of the version number. Note that this encoded"]
    #[doc = " value should be accessed through the macros provided, as the encoding may"]
    #[doc = " change"]
    #[doc = " in the future."]
    #[doc = ""]
    pub fn vpx_codec_version() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\\brief Return the version information (as a string)"]
    #[doc = ""]
    #[doc = " Returns a printable string containing the full library version number. This"]
    #[doc = " may"]
    #[doc = " contain additional text following the three digit version number, as to"]
    #[doc = " indicate"]
    #[doc = " release candidates, prerelease versions, etc."]
    #[doc = ""]
    pub fn vpx_codec_version_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the version information (as a string)"]
    #[doc = ""]
    #[doc = " Returns a printable \"extra string\". This is the component of the string"]
    #[doc = " returned"]
    #[doc = " by vpx_codec_version_str() following the three digit version number."]
    #[doc = ""]
    pub fn vpx_codec_version_extra_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the build configuration"]
    #[doc = ""]
    #[doc = " Returns a printable string containing an encoded version of the build"]
    #[doc = " configuration. This may be useful to vpx support."]
    #[doc = ""]
    pub fn vpx_codec_build_config() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Return the name for a given interface"]
    #[doc = ""]
    #[doc = " Returns a human readable string for name of the given codec interface."]
    #[doc = ""]
    #[doc = " \\param[in]    iface     Interface pointer"]
    #[doc = ""]
    pub fn vpx_codec_iface_name(iface: *mut vpx_codec_iface_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Convert error number to printable string"]
    #[doc = ""]
    #[doc = " Returns a human readable string for the last error returned by the"]
    #[doc = " algorithm. The returned error will be one line and will not contain"]
    #[doc = " any newline characters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param[in]    err     Error number."]
    #[doc = ""]
    pub fn vpx_codec_err_to_string(err: vpx_codec_err_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve error synopsis for codec context"]
    #[doc = ""]
    #[doc = " Returns a human readable string for the last error returned by the"]
    #[doc = " algorithm. The returned error will be one line and will not contain"]
    #[doc = " any newline characters."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = ""]
    pub fn vpx_codec_error(ctx: *mut vpx_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Retrieve detailed error information for codec context"]
    #[doc = ""]
    #[doc = " Returns a human readable string providing detailed information about"]
    #[doc = " the last error."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = ""]
    #[doc = " \\retval NULL"]
    #[doc = "     No detailed information is available."]
    pub fn vpx_codec_error_detail(ctx: *mut vpx_codec_ctx_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "\\brief Destroy a codec instance"]
    #[doc = ""]
    #[doc = " Destroys a codec context, freeing any associated memory buffers."]
    #[doc = ""]
    #[doc = " \\param[in] ctx   Pointer to this instance's context"]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     The codec algorithm initialized."]
    #[doc = " \\retval #VPX_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn vpx_codec_destroy(ctx: *mut vpx_codec_ctx_t) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Get the capabilities of an algorithm."]
    #[doc = ""]
    #[doc = " Retrieves the capabilities bitfield from the algorithm's interface."]
    #[doc = ""]
    #[doc = " \\param[in] iface   Pointer to the algorithm interface"]
    #[doc = ""]
    pub fn vpx_codec_get_caps(iface: *mut vpx_codec_iface_t) -> vpx_codec_caps_t;
}
extern "C" {
    #[doc = "\\brief Control algorithm"]
    #[doc = ""]
    #[doc = " This function is used to exchange algorithm specific data with the codec"]
    #[doc = " instance. This can be used to implement features specific to a particular"]
    #[doc = " algorithm."]
    #[doc = ""]
    #[doc = " This wrapper function dispatches the request to the helper function"]
    #[doc = " associated with the given ctrl_id. It tries to call this function"]
    #[doc = " transparently, but will return #VPX_CODEC_ERROR if the request could not"]
    #[doc = " be dispatched."]
    #[doc = ""]
    #[doc = " Note that this function should not be used directly. Call the"]
    #[doc = " #vpx_codec_control wrapper macro instead."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx              Pointer to this instance's context"]
    #[doc = " \\param[in]     ctrl_id          Algorithm specific control identifier"]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     The control request was processed."]
    #[doc = " \\retval #VPX_CODEC_ERROR"]
    #[doc = "     The control request was not processed."]
    #[doc = " \\retval #VPX_CODEC_INVALID_PARAM"]
    #[doc = "     The data was not valid."]
    pub fn vpx_codec_control_(
        ctx: *mut vpx_codec_ctx_t,
        ctrl_id: ::std::os::raw::c_int,
        ...
    ) -> vpx_codec_err_t;
}
#[doc = "\\brief External frame buffer"]
#[doc = ""]
#[doc = " This structure holds allocated frame buffers used by the decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_frame_buffer {
    #[doc = "< Pointer to the data buffer"]
    pub data: *mut u8,
    #[doc = "< Size of data in bytes"]
    pub size: size_t,
    #[doc = "< Frame's private data"]
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_codec_frame_buffer() {
    assert_eq!(
        ::std::mem::size_of::<vpx_codec_frame_buffer>(),
        24usize,
        concat!("Size of: ", stringify!(vpx_codec_frame_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_codec_frame_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_codec_frame_buffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_frame_buffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_frame_buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_frame_buffer>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_frame_buffer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_frame_buffer>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_frame_buffer),
            "::",
            stringify!(priv_)
        )
    );
}
pub type vpx_codec_frame_buffer_t = vpx_codec_frame_buffer;
#[doc = "\\brief get frame buffer callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to retrieve data for the frame"]
#[doc = " buffer in order for the decode call to complete. The callback must"]
#[doc = " allocate at least min_size in bytes and assign it to fb->data. The callback"]
#[doc = " must zero out all the data allocated. Then the callback must set fb->size"]
#[doc = " to the allocated size. The application does not need to align the allocated"]
#[doc = " data. The callback is triggered when the decoder needs a frame buffer to"]
#[doc = " decode a compressed image into. This function may be called more than once"]
#[doc = " for every call to vpx_codec_decode. The application may set fb->priv to"]
#[doc = " some data which will be passed back in the vpx_image_t and the release"]
#[doc = " function call. |fb| is guaranteed to not be NULL. On success the callback"]
#[doc = " must return 0. Any failure the callback must return a value less than 0."]
#[doc = ""]
#[doc = " \\param[in] priv         Callback's private data"]
#[doc = " \\param[in] min_size     Size in bytes needed by the buffer"]
#[doc = " \\param[in,out] fb       Pointer to vpx_codec_frame_buffer_t"]
pub type vpx_get_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        min_size: size_t,
        fb: *mut vpx_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "\\brief release frame buffer callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder when the frame buffer is not"]
#[doc = " referenced by any other buffers. |fb| is guaranteed to not be NULL. On"]
#[doc = " success the callback must return 0. Any failure the callback must return"]
#[doc = " a value less than 0."]
#[doc = ""]
#[doc = " \\param[in] priv         Callback's private data"]
#[doc = " \\param[in] fb           Pointer to vpx_codec_frame_buffer_t"]
pub type vpx_release_frame_buffer_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        priv_: *mut ::std::os::raw::c_void,
        fb: *mut vpx_codec_frame_buffer_t,
    ) -> ::std::os::raw::c_int,
>;
#[doc = "\\brief Stream properties"]
#[doc = ""]
#[doc = " This structure is used to query or set properties of the decoded"]
#[doc = " stream. Algorithms may extend this structure with data specific"]
#[doc = " to their bitstream by setting the sz member appropriately."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_stream_info {
    #[doc = "< Size of this structure"]
    pub sz: ::std::os::raw::c_uint,
    #[doc = "< Width (or 0 for unknown/default)"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Height (or 0 for unknown/default)"]
    pub h: ::std::os::raw::c_uint,
    #[doc = "< Current frame is a keyframe"]
    pub is_kf: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_codec_stream_info() {
    assert_eq!(
        ::std::mem::size_of::<vpx_codec_stream_info>(),
        16usize,
        concat!("Size of: ", stringify!(vpx_codec_stream_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_codec_stream_info>(),
        4usize,
        concat!("Alignment of ", stringify!(vpx_codec_stream_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_stream_info>())).sz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_stream_info),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_stream_info>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_stream_info),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_stream_info>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_stream_info),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_stream_info>())).is_kf as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_stream_info),
            "::",
            stringify!(is_kf)
        )
    );
}
pub type vpx_codec_stream_info_t = vpx_codec_stream_info;
#[doc = "\\brief Initialization Configurations"]
#[doc = ""]
#[doc = " This structure is used to pass init time configuration options to the"]
#[doc = " decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_dec_cfg {
    #[doc = "< Maximum number of threads to use, default 1"]
    pub threads: ::std::os::raw::c_uint,
    #[doc = "< Width"]
    pub w: ::std::os::raw::c_uint,
    #[doc = "< Height"]
    pub h: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_vpx_codec_dec_cfg() {
    assert_eq!(
        ::std::mem::size_of::<vpx_codec_dec_cfg>(),
        12usize,
        concat!("Size of: ", stringify!(vpx_codec_dec_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_codec_dec_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(vpx_codec_dec_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_dec_cfg>())).threads as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_dec_cfg),
            "::",
            stringify!(threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_dec_cfg>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_dec_cfg),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_codec_dec_cfg>())).h as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_codec_dec_cfg),
            "::",
            stringify!(h)
        )
    );
}
pub type vpx_codec_dec_cfg_t = vpx_codec_dec_cfg;
extern "C" {
    #[doc = "\\brief Initialize a decoder instance"]
    #[doc = ""]
    #[doc = " Initializes a decoder context using the given interface. Applications"]
    #[doc = " should call the vpx_codec_dec_init convenience macro instead of this"]
    #[doc = " function directly, to ensure that the ABI version number parameter"]
    #[doc = " is properly initialized."]
    #[doc = ""]
    #[doc = " If the library was configured with --disable-multithread, this call"]
    #[doc = " is not thread safe and should be guarded with a lock if being used"]
    #[doc = " in a multithreaded context."]
    #[doc = ""]
    #[doc = " \\param[in]    ctx     Pointer to this instance's context."]
    #[doc = " \\param[in]    iface   Pointer to the algorithm interface to use."]
    #[doc = " \\param[in]    cfg     Configuration to use, if known. May be NULL."]
    #[doc = " \\param[in]    flags   Bitfield of VPX_CODEC_USE_* flags"]
    #[doc = " \\param[in]    ver     ABI version number. Must be set to"]
    #[doc = "                       VPX_DECODER_ABI_VERSION"]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     The decoder algorithm initialized."]
    #[doc = " \\retval #VPX_CODEC_MEM_ERROR"]
    #[doc = "     Memory allocation failed."]
    pub fn vpx_codec_dec_init_ver(
        ctx: *mut vpx_codec_ctx_t,
        iface: *mut vpx_codec_iface_t,
        cfg: *const vpx_codec_dec_cfg_t,
        flags: vpx_codec_flags_t,
        ver: ::std::os::raw::c_int,
    ) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Parse stream info from a buffer"]
    #[doc = ""]
    #[doc = " Performs high level parsing of the bitstream. Construction of a decoder"]
    #[doc = " context is not necessary. Can be used to determine if the bitstream is"]
    #[doc = " of the proper format, and to extract information from the stream."]
    #[doc = ""]
    #[doc = " \\param[in]      iface   Pointer to the algorithm interface"]
    #[doc = " \\param[in]      data    Pointer to a block of data to parse"]
    #[doc = " \\param[in]      data_sz Size of the data buffer"]
    #[doc = " \\param[in,out]  si      Pointer to stream info to update. The size member"]
    #[doc = "                         \\ref MUST be properly initialized, but \\ref MAY be"]
    #[doc = "                         clobbered by the algorithm. This parameter \\ref MAY"]
    #[doc = "                         be NULL."]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     Bitstream is parsable and stream information updated"]
    pub fn vpx_codec_peek_stream_info(
        iface: *mut vpx_codec_iface_t,
        data: *const u8,
        data_sz: ::std::os::raw::c_uint,
        si: *mut vpx_codec_stream_info_t,
    ) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Return information about the current stream."]
    #[doc = ""]
    #[doc = " Returns information about the stream that has been parsed during decoding."]
    #[doc = ""]
    #[doc = " \\param[in]      ctx     Pointer to this instance's context"]
    #[doc = " \\param[in,out]  si      Pointer to stream info to update. The size member"]
    #[doc = "                         \\ref MUST be properly initialized, but \\ref MAY be"]
    #[doc = "                         clobbered by the algorithm. This parameter \\ref MAY"]
    #[doc = "                         be NULL."]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     Bitstream is parsable and stream information updated"]
    pub fn vpx_codec_get_stream_info(
        ctx: *mut vpx_codec_ctx_t,
        si: *mut vpx_codec_stream_info_t,
    ) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Decode data"]
    #[doc = ""]
    #[doc = " Processes a buffer of coded data. If the processing results in a new"]
    #[doc = " decoded frame becoming available, put_slice and put_frame callbacks may be"]
    #[doc = " invoked, as appropriate. Encoded data \\ref MUST be passed in DTS (decode"]
    #[doc = " time stamp) order. Frames produced will always be in PTS (presentation"]
    #[doc = " time stamp) order."]
    #[doc = " If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,"]
    #[doc = " data and data_sz can contain a fragment of the encoded frame. Fragment"]
    #[doc = " \\#n must contain at least partition \\#n, but can also contain subsequent"]
    #[doc = " partitions (\\#n+1 - \\#n+i), and if so, fragments \\#n+1, .., \\#n+i must"]
    #[doc = " be empty. When no more data is available, this function should be called"]
    #[doc = " with NULL as data and 0 as data_sz. The memory passed to this function"]
    #[doc = " must be available until the frame has been decoded."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] data         Pointer to this block of new coded data. If"]
    #[doc = "                         NULL, the put_frame callback is invoked for"]
    #[doc = "                         the previously decoded frame."]
    #[doc = " \\param[in] data_sz      Size of the coded data, in bytes."]
    #[doc = " \\param[in] user_priv    Application specific data to associate with"]
    #[doc = "                         this frame."]
    #[doc = " \\param[in] deadline     Soft deadline the decoder should attempt to meet,"]
    #[doc = "                         in us. Set to zero for unlimited."]
    #[doc = ""]
    #[doc = " \\return Returns #VPX_CODEC_OK if the coded data was processed completely"]
    #[doc = "         and future pictures can be decoded without error. Otherwise,"]
    #[doc = "         see the descriptions of the other error codes in ::vpx_codec_err_t"]
    #[doc = "         for recoverability capabilities."]
    pub fn vpx_codec_decode(
        ctx: *mut vpx_codec_ctx_t,
        data: *const u8,
        data_sz: ::std::os::raw::c_uint,
        user_priv: *mut ::std::os::raw::c_void,
        deadline: ::std::os::raw::c_long,
    ) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Decoded frames iterator"]
    #[doc = ""]
    #[doc = " Iterates over a list of the frames available for display. The iterator"]
    #[doc = " storage should be initialized to NULL to start the iteration. Iteration is"]
    #[doc = " complete when this function returns NULL."]
    #[doc = ""]
    #[doc = " The list of available frames becomes valid upon completion of the"]
    #[doc = " vpx_codec_decode call, and remains valid until the next call to"]
    #[doc = " vpx_codec_decode."]
    #[doc = ""]
    #[doc = " \\param[in]     ctx      Pointer to this instance's context"]
    #[doc = " \\param[in,out] iter     Iterator storage, initialized to NULL"]
    #[doc = ""]
    #[doc = " \\return Returns a pointer to an image, if one is ready for display. Frames"]
    #[doc = "         produced will always be in PTS (presentation time stamp) order."]
    pub fn vpx_codec_get_frame(
        ctx: *mut vpx_codec_ctx_t,
        iter: *mut vpx_codec_iter_t,
    ) -> *mut vpx_image_t;
}
#[doc = "\\brief put frame callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to notify the application of"]
#[doc = " the availability of decoded image data."]
pub type vpx_codec_put_frame_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(user_priv: *mut ::std::os::raw::c_void, img: *const vpx_image_t),
>;
extern "C" {
    #[doc = "\\brief Register for notification of frame completion."]
    #[doc = ""]
    #[doc = " Registers a given function to be called when a decoded frame is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb           Pointer to the callback function"]
    #[doc = " \\param[in] user_priv    User's private data"]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     Callback successfully registered."]
    #[doc = " \\retval #VPX_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized."]
    #[doc = " \\retval #VPX_CODEC_INCAPABLE"]
    #[doc = "     Algorithm not capable of posting frame completion."]
    pub fn vpx_codec_register_put_frame_cb(
        ctx: *mut vpx_codec_ctx_t,
        cb: vpx_codec_put_frame_cb_fn_t,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> vpx_codec_err_t;
}
#[doc = "\\brief put slice callback prototype"]
#[doc = ""]
#[doc = " This callback is invoked by the decoder to notify the application of"]
#[doc = " the availability of partially decoded image data."]
pub type vpx_codec_put_slice_cb_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        user_priv: *mut ::std::os::raw::c_void,
        img: *const vpx_image_t,
        valid: *const vpx_image_rect_t,
        update: *const vpx_image_rect_t,
    ),
>;
extern "C" {
    #[doc = "\\brief Register for notification of slice completion."]
    #[doc = ""]
    #[doc = " Registers a given function to be called when a decoded slice is"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb           Pointer to the callback function"]
    #[doc = " \\param[in] user_priv    User's private data"]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     Callback successfully registered."]
    #[doc = " \\retval #VPX_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized."]
    #[doc = " \\retval #VPX_CODEC_INCAPABLE"]
    #[doc = "     Algorithm not capable of posting slice completion."]
    pub fn vpx_codec_register_put_slice_cb(
        ctx: *mut vpx_codec_ctx_t,
        cb: vpx_codec_put_slice_cb_fn_t,
        user_priv: *mut ::std::os::raw::c_void,
    ) -> vpx_codec_err_t;
}
extern "C" {
    #[doc = "\\brief Pass in external frame buffers for the decoder to use."]
    #[doc = ""]
    #[doc = " Registers functions to be called when libvpx needs a frame buffer"]
    #[doc = " to decode the current frame and a function to be called when libvpx does"]
    #[doc = " not internally reference the frame buffer. This set function must"]
    #[doc = " be called before the first call to decode or libvpx will assume the"]
    #[doc = " default behavior of allocating frame buffers internally."]
    #[doc = ""]
    #[doc = " \\param[in] ctx          Pointer to this instance's context"]
    #[doc = " \\param[in] cb_get       Pointer to the get callback function"]
    #[doc = " \\param[in] cb_release   Pointer to the release callback function"]
    #[doc = " \\param[in] cb_priv      Callback's private data"]
    #[doc = ""]
    #[doc = " \\retval #VPX_CODEC_OK"]
    #[doc = "     External frame buffers will be used by libvpx."]
    #[doc = " \\retval #VPX_CODEC_INVALID_PARAM"]
    #[doc = "     One or more of the callbacks were NULL."]
    #[doc = " \\retval #VPX_CODEC_ERROR"]
    #[doc = "     Decoder context not initialized."]
    #[doc = " \\retval #VPX_CODEC_INCAPABLE"]
    #[doc = "     Algorithm not capable of using external frame buffers."]
    #[doc = ""]
    #[doc = " \\note"]
    #[doc = " When decoding VP9, the application may be required to pass in at least"]
    #[doc = " #VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS external frame"]
    #[doc = " buffers."]
    pub fn vpx_codec_set_frame_buffer_functions(
        ctx: *mut vpx_codec_ctx_t,
        cb_get: vpx_get_frame_buffer_cb_fn_t,
        cb_release: vpx_release_frame_buffer_cb_fn_t,
        cb_priv: *mut ::std::os::raw::c_void,
    ) -> vpx_codec_err_t;
}
#[doc = "\\brief pass in an external frame into decoder to be used as reference frame"]
pub const vp8_com_control_id_VP8_SET_REFERENCE: vp8_com_control_id = 1;
#[doc = "< get a copy of reference frame from the decoder"]
pub const vp8_com_control_id_VP8_COPY_REFERENCE: vp8_com_control_id = 2;
#[doc = "< set the decoder's post processing settings"]
pub const vp8_com_control_id_VP8_SET_POSTPROC: vp8_com_control_id = 3;
#[doc = "< get a pointer to a reference frame"]
pub const vp8_com_control_id_VP9_GET_REFERENCE: vp8_com_control_id = 128;
pub const vp8_com_control_id_VP8_COMMON_CTRL_ID_MAX: vp8_com_control_id = 129;
pub const vp8_com_control_id_VP8_DECODER_CTRL_ID_START: vp8_com_control_id = 256;
#[doc = "\\brief Control functions"]
#[doc = ""]
#[doc = " The set of macros define the control functions of VP8 interface"]
pub type vp8_com_control_id = ::std::os::raw::c_uint;
pub const vp8_postproc_level_VP8_NOFILTERING: vp8_postproc_level = 0;
pub const vp8_postproc_level_VP8_DEBLOCK: vp8_postproc_level = 1;
pub const vp8_postproc_level_VP8_DEMACROBLOCK: vp8_postproc_level = 2;
pub const vp8_postproc_level_VP8_ADDNOISE: vp8_postproc_level = 4;
pub const vp8_postproc_level_VP8_MFQE: vp8_postproc_level = 8;
#[doc = "\\brief post process flags"]
#[doc = ""]
#[doc = " The set of macros define VP8 decoder post processing flags"]
pub type vp8_postproc_level = ::std::os::raw::c_uint;
#[doc = "\\brief post process flags"]
#[doc = ""]
#[doc = " This define a structure that describe the post processing settings. For"]
#[doc = " the best objective measure (using the PSNR metric) set post_proc_flag"]
#[doc = " to VP8_DEBLOCK and deblocking_level to 1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vp8_postproc_cfg {
    #[doc = "\\brief the types of post processing to be done, should be combination of"]
    #[doc = " \"vp8_postproc_level\""]
    pub post_proc_flag: ::std::os::raw::c_int,
    #[doc = "< the strength of deblocking, valid range [0, 16]"]
    pub deblocking_level: ::std::os::raw::c_int,
    #[doc = "< the strength of additive noise, valid range [0, 16]"]
    pub noise_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_vp8_postproc_cfg() {
    assert_eq!(
        ::std::mem::size_of::<vp8_postproc_cfg>(),
        12usize,
        concat!("Size of: ", stringify!(vp8_postproc_cfg))
    );
    assert_eq!(
        ::std::mem::align_of::<vp8_postproc_cfg>(),
        4usize,
        concat!("Alignment of ", stringify!(vp8_postproc_cfg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vp8_postproc_cfg>())).post_proc_flag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vp8_postproc_cfg),
            "::",
            stringify!(post_proc_flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vp8_postproc_cfg>())).deblocking_level as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vp8_postproc_cfg),
            "::",
            stringify!(deblocking_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vp8_postproc_cfg>())).noise_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vp8_postproc_cfg),
            "::",
            stringify!(noise_level)
        )
    );
}
pub type vp8_postproc_cfg_t = vp8_postproc_cfg;
pub const vpx_ref_frame_type_VP8_LAST_FRAME: vpx_ref_frame_type = 1;
pub const vpx_ref_frame_type_VP8_GOLD_FRAME: vpx_ref_frame_type = 2;
pub const vpx_ref_frame_type_VP8_ALTR_FRAME: vpx_ref_frame_type = 4;
#[doc = "\\brief reference frame type"]
#[doc = ""]
#[doc = " The set of macros define the type of VP8 reference frames"]
pub type vpx_ref_frame_type = ::std::os::raw::c_uint;
pub use self::vpx_ref_frame_type as vpx_ref_frame_type_t;
#[doc = "\\brief reference frame data struct"]
#[doc = ""]
#[doc = " Define the data struct to access vp8 reference frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_ref_frame {
    #[doc = "< which reference frame"]
    pub frame_type: vpx_ref_frame_type_t,
    #[doc = "< reference frame data in image format"]
    pub img: vpx_image_t,
}
#[test]
fn bindgen_test_layout_vpx_ref_frame() {
    assert_eq!(
        ::std::mem::size_of::<vpx_ref_frame>(),
        144usize,
        concat!("Size of: ", stringify!(vpx_ref_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_ref_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_ref_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_ref_frame>())).frame_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_ref_frame),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_ref_frame>())).img as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_ref_frame),
            "::",
            stringify!(img)
        )
    );
}
pub type vpx_ref_frame_t = vpx_ref_frame;
#[doc = "\\brief VP9 specific reference frame data struct"]
#[doc = ""]
#[doc = " Define the data struct to access vp9 reference frames."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vp9_ref_frame {
    #[doc = "< frame index to get (input)"]
    pub idx: ::std::os::raw::c_int,
    #[doc = "< img structure to populate (output)"]
    pub img: vpx_image_t,
}
#[test]
fn bindgen_test_layout_vp9_ref_frame() {
    assert_eq!(
        ::std::mem::size_of::<vp9_ref_frame>(),
        144usize,
        concat!("Size of: ", stringify!(vp9_ref_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<vp9_ref_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(vp9_ref_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vp9_ref_frame>())).idx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vp9_ref_frame),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vp9_ref_frame>())).img as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vp9_ref_frame),
            "::",
            stringify!(img)
        )
    );
}
pub type vp9_ref_frame_t = vp9_ref_frame;
extern "C" {
    #[doc = "\\name Algorithm interface for VP8"]
    #[doc = ""]
    #[doc = " This interface provides the capability to decode VP8 streams."]
    #[doc = " @{"]
    pub static mut vpx_codec_vp8_dx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp8_dx() -> *mut vpx_codec_iface_t;
}
extern "C" {
    #[doc = "\\name Algorithm interface for VP9"]
    #[doc = ""]
    #[doc = " This interface provides the capability to decode VP9 streams."]
    #[doc = " @{"]
    pub static mut vpx_codec_vp9_dx_algo: vpx_codec_iface_t;
}
extern "C" {
    pub fn vpx_codec_vp9_dx() -> *mut vpx_codec_iface_t;
}
#[doc = " control function to get info on which reference frames were updated"]
#[doc = "  by the last decode"]
pub const vp8_dec_control_id_VP8D_GET_LAST_REF_UPDATES: vp8_dec_control_id = 256;
#[doc = " check if the indicated frame is corrupted"]
pub const vp8_dec_control_id_VP8D_GET_FRAME_CORRUPTED: vp8_dec_control_id = 257;
#[doc = " control function to get info on which reference frames were used"]
#[doc = "  by the last decode"]
pub const vp8_dec_control_id_VP8D_GET_LAST_REF_USED: vp8_dec_control_id = 258;
#[doc = " decryption function to decrypt encoded buffer data immediately"]
#[doc = " before decoding. Takes a vpx_decrypt_init, which contains"]
#[doc = " a callback function and opaque context pointer."]
pub const vp8_dec_control_id_VPXD_SET_DECRYPTOR: vp8_dec_control_id = 259;
#[doc = " decryption function to decrypt encoded buffer data immediately"]
#[doc = " before decoding. Takes a vpx_decrypt_init, which contains"]
#[doc = " a callback function and opaque context pointer."]
pub const vp8_dec_control_id_VP8D_SET_DECRYPTOR: vp8_dec_control_id = 259;
#[doc = " control function to get the dimensions that the current frame is decoded"]
#[doc = " at. This may be different to the intended display size for the frame as"]
#[doc = " specified in the wrapper or frame header (see VP9D_GET_DISPLAY_SIZE)."]
pub const vp8_dec_control_id_VP9D_GET_FRAME_SIZE: vp8_dec_control_id = 260;
#[doc = " control function to get the current frame's intended display dimensions"]
#[doc = " (as specified in the wrapper or frame header). This may be different to"]
#[doc = " the decoded dimensions of this frame (see VP9D_GET_FRAME_SIZE)."]
pub const vp8_dec_control_id_VP9D_GET_DISPLAY_SIZE: vp8_dec_control_id = 261;
#[doc = " control function to get the bit depth of the stream."]
pub const vp8_dec_control_id_VP9D_GET_BIT_DEPTH: vp8_dec_control_id = 262;
#[doc = " control function to set the byte alignment of the planes in the reference"]
#[doc = " buffers. Valid values are power of 2, from 32 to 1024. A value of 0 sets"]
#[doc = " legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly"]
#[doc = " follows Y plane, and V plane directly follows U plane. Default value is 0."]
pub const vp8_dec_control_id_VP9_SET_BYTE_ALIGNMENT: vp8_dec_control_id = 263;
#[doc = " control function to invert the decoding order to from right to left. The"]
#[doc = " function is used in a test to confirm the decoding independence of tile"]
#[doc = " columns. The function may be used in application where this order"]
#[doc = " of decoding is desired."]
#[doc = ""]
#[doc = " TODO(yaowu): Rework the unit test that uses this control, and in a future"]
#[doc = "              release, this test-only control shall be removed."]
pub const vp8_dec_control_id_VP9_INVERT_TILE_DECODE_ORDER: vp8_dec_control_id = 264;
#[doc = " control function to set the skip loop filter flag. Valid values are"]
#[doc = " integers. The decoder will skip the loop filter when its value is set to"]
#[doc = " nonzero. If the loop filter is skipped the decoder may accumulate decode"]
#[doc = " artifacts. The default value is 0."]
pub const vp8_dec_control_id_VP9_SET_SKIP_LOOP_FILTER: vp8_dec_control_id = 265;
#[doc = " control function to decode SVC stream up to the x spatial layers,"]
#[doc = " where x is passed in through the control, and is 0 for base layer."]
pub const vp8_dec_control_id_VP9_DECODE_SVC_SPATIAL_LAYER: vp8_dec_control_id = 266;
#[doc = "\\brief Codec control function to get last decoded frame quantizer."]
#[doc = ""]
#[doc = " Return value uses internal quantizer scale defined by the codec."]
#[doc = ""]
#[doc = " Supported in codecs: VP8, VP9"]
pub const vp8_dec_control_id_VPXD_GET_LAST_QUANTIZER: vp8_dec_control_id = 267;
#[doc = "\\brief Codec control function to set row level multi-threading."]
#[doc = ""]
#[doc = " 0 : off, 1 : on"]
#[doc = ""]
#[doc = " Supported in codecs: VP9"]
pub const vp8_dec_control_id_VP9D_SET_ROW_MT: vp8_dec_control_id = 268;
#[doc = "\\brief Codec control function to set loopfilter optimization."]
#[doc = ""]
#[doc = " 0 : off, Loop filter is done after all tiles have been decoded"]
#[doc = " 1 : on, Loop filter is done immediately after decode without"]
#[doc = "     waiting for all threads to sync."]
#[doc = ""]
#[doc = " Supported in codecs: VP9"]
pub const vp8_dec_control_id_VP9D_SET_LOOP_FILTER_OPT: vp8_dec_control_id = 269;
#[doc = "\\brief Codec control function to set loopfilter optimization."]
#[doc = ""]
#[doc = " 0 : off, Loop filter is done after all tiles have been decoded"]
#[doc = " 1 : on, Loop filter is done immediately after decode without"]
#[doc = "     waiting for all threads to sync."]
#[doc = ""]
#[doc = " Supported in codecs: VP9"]
pub const vp8_dec_control_id_VP8_DECODER_CTRL_ID_MAX: vp8_dec_control_id = 270;
#[doc = "\\enum vp8_dec_control_id"]
#[doc = " \\brief VP8 decoder control functions"]
#[doc = ""]
#[doc = " This set of macros define the control functions available for the VP8"]
#[doc = " decoder interface."]
#[doc = ""]
#[doc = " \\sa #vpx_codec_control"]
pub type vp8_dec_control_id = ::std::os::raw::c_uint;
#[doc = " Decrypt n bytes of data from input -> output, using the decrypt_state"]
#[doc = "  passed in VPXD_SET_DECRYPTOR."]
pub type vpx_decrypt_cb = ::std::option::Option<
    unsafe extern "C" fn(
        decrypt_state: *mut ::std::os::raw::c_void,
        input: *const ::std::os::raw::c_uchar,
        output: *mut ::std::os::raw::c_uchar,
        count: ::std::os::raw::c_int,
    ),
>;
#[doc = "\\brief Structure to hold decryption state"]
#[doc = ""]
#[doc = " Defines a structure to hold the decryption state and access function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_decrypt_init {
    #[doc = " Decrypt callback."]
    pub decrypt_cb: vpx_decrypt_cb,
    #[doc = " Decryption state."]
    pub decrypt_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vpx_decrypt_init() {
    assert_eq!(
        ::std::mem::size_of::<vpx_decrypt_init>(),
        16usize,
        concat!("Size of: ", stringify!(vpx_decrypt_init))
    );
    assert_eq!(
        ::std::mem::align_of::<vpx_decrypt_init>(),
        8usize,
        concat!("Alignment of ", stringify!(vpx_decrypt_init))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_decrypt_init>())).decrypt_cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_decrypt_init),
            "::",
            stringify!(decrypt_cb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vpx_decrypt_init>())).decrypt_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vpx_decrypt_init),
            "::",
            stringify!(decrypt_state)
        )
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vpx_codec_enc_cfg {
    pub _address: u8,
}
